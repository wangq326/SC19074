---
title: "Homework of R base"
author: '19074'
date: "2019/12/13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Exercise 3 from page 204

+ Use both for loops and lapply() to ﬁt linear models to the mtcars using the formulas stored in this list:
+ formulas <- list(mpg ~ disp, mpg ~ I(1/disp), mpg ~ disp+wt,mpg ~ I(1/disp)+wt) 

```{r}
data("mtcars")
formulas <- list(mpg~disp, mpg~I(1/disp), mpg~disp+wt,mpg~I(1/disp)+wt)
lm.loop <- list()
for (i in 1:4) {
  lm.loop[[i]] <- lm(formulas[[i]],data = mtcars)
}
lm.lapply <- lapply(formulas, lm,data=mtcars)
lm.loop
lm.lapply
```

## Exercise 4 from page 204

+ Fit the model mpg~disp to each of the bootstrap replicates of mtcars in the list below by using a for loop and lapply(). 
Can you do it without an anonymous function?
  +  bootstraps <- lapply(1:10, function(i) {
      +    rows <- sample(1:nrow(mtcars), rep = TRUE) 
      +    mtcars[rows, ] }) 

```{r}
boot.sample <- function(i){
  rows <- sample(1:nrow(mtcars), rep = TRUE) 
  mtcars[rows, ]
}

lm.loop2 <- list()
for (i in 1:10) {
  lm.loop2[[i]] <- lm(mpg~disp,data = boot.sample(i))
}

lm.lapply2 <- lapply(lapply(1:10, boot.sample),lm,formula=mpg~disp)

lm.loop2
lm.lapply2
```


## Exercise 5 from page 204

+ For each model in the previous two exercises,extract $R^2$ using the function below.
+ rsq <- function(mod) summary(mod)$r.squared

```{r}
rsq <- function(mod) summary(mod)$r.squared

r2.ex3.loop <- lapply(lm.loop, rsq)
r2.ex3.lapply <- lapply(lm.lapply,rsq)

r2.ex4.loop <- lapply(lm.loop2, rsq)
r2.ex4.lapply <- lapply(lm.lapply2, rsq)

r2.ex3 <- cbind(model=as.character(formulas),r2.ex3.loop,r2.ex3.lapply)
r2.ex4 <- cbind(r2.ex4.loop,r2.ex4.lapply)

r2.ex3
r2.ex4
```

## Exercise 3 from page 214

+ The following code simulates the performance of a t-test for non-normal data. Use sapply() and an anonymous function to extract the p-value from every trial.
+ trials <- replicate(100,t.test(rpois(10,10),rpois(7,10)),simplify = FALSE) 
+ Extra challenge: get rid of the anonymous function by using [[ directly. 

```{r}
set.seed(123)
trials <- replicate(100,t.test(rpois(10,10),rpois(7,10)),simplify = FALSE) 

# Use sapply() and an anonymous function to extract the p-value from every trial.
pv1 <- sapply(trials, function(x) x$p.value)
# Extra challenge: get rid of the anonymous function by using [[ directly.
pv2 <- sapply(trials,"[[",3)

cbind(pv1,pv2)
```

## Exercise 7 from page 214

+ Implement mcsapply(), a multicore version of sapply(). 
+ Can you implement mcvapply(), a parallel version of vapply()? Why or why not?

```{r}
library(parallel)
mcsapply <- function(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE, chunk.size = NULL){
  # 计算可用线程数，并设置并行使用线程数
  no_cores <- detectCores() - 1
  # 初始化
  cl <- makeCluster(no_cores)
  ans <- parSapply(cl, X, FUN, ..., simplify = TRUE,
            USE.NAMES = TRUE, chunk.size = NULL)
  stopCluster(cl)
  return(ans)
}


# example
mcsapply(trials,function(x) x$p.value)
```

> We can't implement Mcvapply. The superficial reason is that we cannot find a parVapply similar to parSapply versus sapply. The essential reason I think is that the working mechanism of vapply is causing it to have no way to parallelize.




